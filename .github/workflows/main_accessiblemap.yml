# Docs for the Azure Web Apps Deploy action: https://github.com/Azure/webapps-deploy
name: Build and deploy Node.js app to Azure Web App - accessiblemap
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # Checkout the repository
      - name: Checkout GitHub repository
        uses: actions/checkout@v4

      # Set up Node.js environment
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # Install frontend dependencies
      - name: Install frontend dependencies
        run: npm ci

      # Install backend dependencies
      - name: Install backend dependencies
        working-directory: ./server
        run: npm ci

      # Build the frontend
      - name: Build the frontend
        run: npm run build:frontend
        env:
          VITE_OPENROUTE_API_KEY: ${{ secrets.VITE_OPENROUTE_API_KEY }}

      # Build the backend
      - name: Build the backend
        working-directory: ./server
        run: npm run build

      # Copy server package.json for dependency installation
      - name: Copy server package.json
        run: cp ./server/package.json ./server/dist/

      # Remove type:module from package.json if present
      - name: Check if package.json has type:module
        working-directory: ./server/dist
        run: |
          if grep -q '"type"\s*:\s*"module"' package.json; then
            echo "Removing type:module from package.json"
            node -e "const pkg = require('./package.json'); delete pkg.type; require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2));"
          fi

      # Install dependencies in server/dist
      - name: Install dependencies in server/dist
        working-directory: ./server/dist
        run: npm install --production

      # Copy frontend files directly to server/dist
      - name: Copy frontend files
        run: |
          cp -r ./dist/* ./server/dist/ || echo "No frontend files to copy"

      # Create production app with database support
      - name: Create production app
        working-directory: ./server/dist
        run: |
          cat > production-app.js << 'EOL'
          const express = require("express");
          const helmet = require("helmet");
          const compression = require("compression");
          const cors = require("cors");
          const path = require("path");
          const fs = require("fs");
          const crypto = require("crypto");
          
          // Create log directory
          const logDir = path.join(__dirname, "logs");
          if (!fs.existsSync(logDir)) {
            fs.mkdirSync(logDir);
          }
          
          // Setup logging
          const logFile = path.join(logDir, "app.log");
          const log = (...args) => {
            const message = args.map(arg => 
              typeof arg === "object" ? JSON.stringify(arg, null, 2) : arg
            ).join(" ");
            const timestamp = new Date().toISOString();
            const logMessage = `${timestamp}: ${message}\n`;
            console.log(message);
            try {
              fs.appendFileSync(logFile, logMessage);
            } catch (err) {
              console.error("Failed to write to log file:", err);
            }
          };
          
          // Global error handler
          process.on("uncaughtException", (err) => {
            log(`UNCAUGHT EXCEPTION: ${err.message}`);
            log(err.stack);
          });
          
          process.on("unhandledRejection", (reason, promise) => {
            log(`UNHANDLED REJECTION: ${reason}`);
          });
          
          log("Starting production app...");
          
          const app = express();
          const PORT = process.env.PORT || 8080;
          
          log("Setting up middleware...");
          
          // Middleware
          app.use(helmet({
            contentSecurityPolicy: false
          }));
          app.use(compression());
          app.use(cors({
            origin: "*",
            methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
            credentials: true
          }));
          app.use(express.json());
          
          // Database connection state
          let dbConnected = false;
          let dbConnection = null;
          
          // In-memory user storage (fallback when DB is unavailable)
          const users = [
            { id: 1, username: "user1", email: "user1@example.com", password: "hashedpassword1", location: { lat: 40.7128, lng: -74.0060 } },
            { id: 2, username: "user2", email: "user2@example.com", password: "hashedpassword2", location: { lat: 34.0522, lng: -118.2437 } }
          ];
          
          // Create tables if they don't exist
          const setupDatabase = async (db) => {
            try {
              log("Checking if Users table exists...");
              
              // Check if Users table exists
              const tableCheck = await db.request().query(`
                SELECT OBJECT_ID('dbo.Users') as TableID
              `);
              
              if (!tableCheck.recordset[0].TableID) {
                log("Users table does not exist. Creating...");
                
                // Create Users table
                await db.request().query(`
                  CREATE TABLE Users (
                    id INT PRIMARY KEY IDENTITY(1,1),
                    username NVARCHAR(255) NOT NULL,
                    email NVARCHAR(255) NOT NULL UNIQUE,
                    password NVARCHAR(255) NOT NULL,
                    latitude FLOAT NULL,
                    longitude FLOAT NULL,
                    created_at DATETIME DEFAULT GETDATE(),
                    updated_at DATETIME DEFAULT GETDATE()
                  )
                `);
                
                log("Users table created successfully.");
              } else {
                log("Users table already exists.");
              }
              
              return true;
            } catch (err) {
              log(`Error setting up database: ${err.message}`);
              log(err.stack);
              return false;
            }
          };
          
          // Database connection function with retry
          const connectToDatabase = async (retryCount = 0) => {
            const maxRetries = 3;
            const DB_HOST = process.env.DB_HOST;
            const DB_USER = process.env.DB_USER;
            const DB_PASS = process.env.DB_PASS;
            const DB_NAME = process.env.DB_NAME;
            
            if (!DB_HOST || !DB_USER || !DB_PASS || !DB_NAME) {
              log("Missing database environment variables. Check your configuration.");
              return null;
            }
            
            log("Connecting to database...");
            log(`DB_HOST: ${DB_HOST}`);
            log(`DB_USER: ${DB_USER}`);
            log(`DB_NAME: ${DB_NAME}`);
            
            try {
              // Dynamically import the database module to avoid errors if not available
              const sql = require("mssql");
              
              const config = {
                user: DB_USER,
                password: DB_PASS,
                server: DB_HOST,
                database: DB_NAME,
                options: {
                  encrypt: true,
                  trustServerCertificate: false,
                  connectionTimeout: 30000
                }
              };
              
              // Add timeout for connection
              const connectionPromise = sql.connect(config);
              
              const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error("Database connection timeout after 30 seconds")), 30000);
              });
              
              const pool = await Promise.race([connectionPromise, timeoutPromise]);
              
              log("Database connection successful");
              dbConnected = true;
              dbConnection = pool;
              
              // Setup database tables
              await setupDatabase(pool);
              
              return pool;
            } catch (err) {
              log(`Database connection error: ${err.message}`);
              log(err.stack);
              
              if (retryCount < maxRetries) {
                const delay = 1000 * Math.pow(2, retryCount);
                log(`Retrying database connection in ${delay}ms (attempt ${retryCount + 1}/${maxRetries})...`);
                return new Promise(resolve => {
                  setTimeout(() => {
                    resolve(connectToDatabase(retryCount + 1));
                  }, delay);
                });
              } else {
                log("Maximum retry attempts reached. Database connection failed.");
              }
              
              return null;
            }
          };
          
          // Initialize database connection without blocking app startup
          connectToDatabase().catch(err => {
            log(`Initial database connection failed: ${err.message}`);
          });
          
          // Middleware to handle database access
          app.use((req, res, next) => {
            req.db = dbConnection;
            req.dbConnected = dbConnected;
            req.users = users; // Fallback user data
            next();
          });
          
          // API routes
          log("Setting up API routes...");
          
          // Health check endpoint
          app.get("/health", (req, res) => {
            log("Health check endpoint hit");
            res.status(200).json({ 
              status: "OK",
              database: dbConnected ? "connected" : "disconnected",
              environment: process.env.NODE_ENV || "development"
            });
          });
          
          // Add geolocation fallback API
          app.get("/api/geolocation", (req, res) => {
            log("Geolocation fallback API hit");
            // Return a default location (New York City)
            res.json({
              status: "success",
              location: {
                latitude: 40.7128,
                longitude: -74.0060,
                accuracy: 1000,
                source: "mock"
              }
            });
          });
          
          // User signup API
          app.post("/api/signup", async (req, res) => {
            log("Signup API hit");
            log(`Request body: ${JSON.stringify(req.body, null, 2)}`);
            
            try {
              const { username, email, password, location } = req.body;
              
              if (!username || !email || !password) {
                return res.status(400).json({ 
                  status: "error", 
                  message: "Missing required fields" 
                });
              }
              
              // Simple email validation
              if (!email.includes("@")) {
                return res.status(400).json({ 
                  status: "error", 
                  message: "Invalid email format" 
                });
              }
              
              // Hash password (simple version)
              const hashedPassword = crypto
                .createHash("sha256")
                .update(password)
                .digest("hex");
              
              if (req.dbConnected) {
                log("Attempting to save user to database");
                try {
                  // Check if user already exists
                  const userCheck = await req.db.request()
                    .input("email", req.db.VarChar(255), email)
                    .query("SELECT * FROM Users WHERE email = @email");
                    
                  if (userCheck.recordset.length > 0) {
                    return res.status(409).json({ 
                      status: "error", 
                      message: "User with this email already exists" 
                    });
                  }
                  
                  // Extract location data
                  const latitude = location?.latitude || location?.lat || null;
                  const longitude = location?.longitude || location?.lng || null;
                  
                  log(`Inserting user with: username=${username}, email=${email}, latitude=${latitude}, longitude=${longitude}`);
                  
                  // Insert new user
                  const result = await req.db.request()
                    .input("username", req.db.VarChar(255), username)
                    .input("email", req.db.VarChar(255), email)
                    .input("password", req.db.VarChar(255), hashedPassword)
                    .input("latitude", req.db.Float, latitude)
                    .input("longitude", req.db.Float, longitude)
                    .query(`
                      INSERT INTO Users (username, email, password, latitude, longitude) 
                      VALUES (@username, @email, @password, @latitude, @longitude);
                      SELECT SCOPE_IDENTITY() AS id;
                    `);
                  
                  const userId = result.recordset[0].id;
                  
                  log(`User created successfully with ID: ${userId}`);
                  return res.status(201).json({
                    status: "success",
                    message: "User created successfully",
                    user: {
                      id: userId,
                      username,
                      email
                    }
                  });
                } catch (dbErr) {
                  log(`Database error during signup: ${dbErr.message}`);
                  log(dbErr.stack);
                  
                  // Fall back to in-memory storage
                  log("Falling back to in-memory storage due to database error");
                }
              } else {
                log("Database not connected, using in-memory storage");
              }
              
              // Fallback: in-memory storage
              // Check if user exists in memory
              const existingUser = users.find(u => u.email === email);
              if (existingUser) {
                return res.status(409).json({ 
                  status: "error", 
                  message: "User with this email already exists" 
                });
              }
              
              // Create new user in memory
              const newUser = {
                id: users.length + 1,
                username,
                email,
                password: hashedPassword,
                location: location || { lat: null, lng: null }
              };
              
              users.push(newUser);
              
              log(`User created in memory with ID: ${newUser.id}`);
              return res.status(201).json({
                status: "success",
                message: "User created successfully (in-memory)",
                user: {
                  id: newUser.id,
                  username,
                  email
                }
              });
            } catch (err) {
              log(`Error in signup process: ${err.message}`);
              log(err.stack);
              return res.status(500).json({
                status: "error",
                message: "Server error during signup"
              });
            }
          });
          
          // User login API
          app.post("/api/login", async (req, res) => {
            log("Login API hit");
            log(`Login request body: ${JSON.stringify(req.body, null, 2)}`);
            
            try {
              const { email, password } = req.body;
              
              if (!email || !password) {
                return res.status(400).json({ 
                  status: "error", 
                  message: "Missing email or password" 
                });
              }
              
              // Hash password for comparison
              const hashedPassword = crypto
                .createHash("sha256")
                .update(password)
                .digest("hex");
              
              if (req.dbConnected) {
                try {
                  const result = await req.db.request()
                    .input("email", req.db.VarChar(255), email)
                    .query("SELECT * FROM Users WHERE email = @email");
                    
                  if (result.recordset.length === 0) {
                    return res.status(401).json({ 
                      status: "error", 
                      message: "Invalid email or password" 
                    });
                  }
                  
                  const user = result.recordset[0];
                  
                  if (user.password !== hashedPassword) {
                    return res.status(401).json({ 
                      status: "error", 
                      message: "Invalid email or password" 
                    });
                  }
                  
                  log(`User ${user.id} logged in successfully`);
                  return res.json({
                    status: "success",
                    message: "Login successful",
                    user: {
                      id: user.id,
                      username: user.username,
                      email: user.email
                    }
                  });
                } catch (dbErr) {
                  log(`Database error during login: ${dbErr.message}`);
                  log("Falling back to in-memory login due to database error");
                }
              } else {
                log("Database not connected, using in-memory login");
              }
              
              // Fallback: in-memory storage
              const user = users.find(u => u.email === email);
              
              if (!user || user.password !== hashedPassword) {
                return res.status(401).json({ 
                  status: "error", 
                  message: "Invalid email or password" 
                });
              }
              
              log(`User ${user.id} logged in successfully (in-memory)`);
              return res.json({
                status: "success",
                message: "Login successful (in-memory)",
                user: {
                  id: user.id,
                  username: user.username,
                  email: user.email
                }
              });
            } catch (err) {
              log(`Error in login process: ${err.message}`);
              log(err.stack);
              return res.status(500).json({
                status: "error",
                message: "Server error during login"
              });
            }
          });
          
          // User routes with DB fallback
          app.get("/api/users", async (req, res) => {
            log("GET /api/users endpoint hit");
            
            if (!req.dbConnected) {
              log("Database not connected, returning mock data");
              return res.json(users.map(({ password, ...user }) => user));
            }
            
            try {
              const result = await req.db.request().query("SELECT id, username, email FROM Users");
              log(`Retrieved ${result.recordset.length} users from database`);
              res.json(result.recordset);
            } catch (err) {
              log(`Error querying users: ${err.message}`);
              res.status(500).json({
                error: "Database error",
                message: err.message
              });
            }
          });
          
          app.get("/api/users/:id", async (req, res) => {
            const userId = req.params.id;
            log(`GET /api/users/${userId} endpoint hit`);
            
            if (!req.dbConnected) {
              log("Database not connected, returning mock data");
              const user = users.find(u => u.id === parseInt(userId));
              
              if (!user) {
                return res.status(404).json({ error: "User not found" });
              }
              
              const { password, ...userData } = user;
              return res.json(userData);
            }
            
            try {
              const result = await req.db.request()
                .input("id", req.db.Int, parseInt(userId))
                .query("SELECT id, username, email FROM Users WHERE id = @id");
                
              if (result.recordset.length === 0) {
                return res.status(404).json({ error: "User not found" });
              }
              
              res.json(result.recordset[0]);
            } catch (err) {
              log(`Error querying user ${userId}: ${err.message}`);
              res.status(500).json({
                error: "Database error",
                message: err.message
              });
            }
          });
          
          // Serve static frontend files
          const staticPath = path.resolve(__dirname);
          log(`Serving static files from: ${staticPath}`);
          app.use(express.static(staticPath));
          
          // Catch-all route for SPA
          app.get("*", (req, res) => {
            log(`Catch-all route hit for: ${req.url}`);
            const indexPath = path.join(__dirname, "index.html");
            log(`Serving index.html from: ${indexPath}`);
            res.sendFile(indexPath, (err) => {
              if (err) {
                log(`Error serving index.html: ${err.message}`);
                res.status(500).send("Server error");
              }
            });
          });
          
          // Error handling middleware
          app.use((err, req, res, next) => {
            log(`Express error handler: ${err.message}`);
            log(err.stack);
            res.status(500).json({
              error: "Server error",
              message: err.message
            });
          });
          
          // Start the server
          app.listen(PORT, () => {
            log(`Production app running on port ${PORT}`);
          });
          EOL
          
          # Update package.json
          node -e "const pkg = require('./package.json'); pkg.main = 'production-app.js'; pkg.scripts = pkg.scripts || {}; pkg.scripts.start = 'node production-app.js'; require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2));"

      # Create web.config for Azure
      - name: Create web.config for Azure
        working-directory: ./server/dist
        run: |
          cat > web.config << 'EOL'
          <?xml version="1.0" encoding="utf-8"?>
          <configuration>
            <system.webServer>
              <handlers>
                <add name="iisnode" path="production-app.js" verb="*" modules="iisnode" />
              </handlers>
              <rewrite>
                <rules>
                  <rule name="API">
                    <match url="api/*" />
                    <action type="Rewrite" url="production-app.js" />
                  </rule>
                  <rule name="Health">
                    <match url="health" />
                    <action type="Rewrite" url="production-app.js" />
                  </rule>
                  <rule name="StaticContent">
                    <match url="(.*)" />
                    <conditions>
                      <add input="{REQUEST_FILENAME}" matchType="IsFile" />
                    </conditions>
                    <action type="None" />
                  </rule>
                  <rule name="DynamicContent">
                    <match url=".*" />
                    <conditions>
                      <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
                    </conditions>
                    <action type="Rewrite" url="production-app.js" />
                  </rule>
                </rules>
              </rewrite>
              <iisnode 
                watchedFiles="web.config;*.js"
                loggingEnabled="true"
                logDirectory="iisnode" 
                debuggingEnabled="true" />
            </system.webServer>
          </configuration>
          EOL

      # Log deployment package contents
      - name: Log deployment package contents
        run: |
          echo "Deployment package contents:"
          ls -la ./server/dist/

      # Deploy to Azure App Service
      - name: Deploy to Azure App Service
        uses: azure/webapps-deploy@v3
        with:
          app-name: accessiblemap
          slot-name: production
          package: ./server/dist
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
